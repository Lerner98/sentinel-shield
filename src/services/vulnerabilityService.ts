import { supabase } from "@/integrations/supabase/client";
import {
  ScanFinding,
  CreateVulnerabilityDto,
  SeverityLevel,
  ApiResponse,
} from "./types";

export const vulnerabilityService = {
  /**
   * Get all vulnerabilities for a scan
   */
  async getByScanId(scanId: string): Promise<ApiResponse<ScanFinding[]>> {
    try {
      const { data, error } = await supabase
        .from("scan_findings")
        .select("*")
        .eq("scan_id", scanId)
        .order("created_at", { ascending: false });

      if (error) throw error;

      return { data: data || [] };
    } catch (error) {
      console.error("Error fetching vulnerabilities:", error);
      return {
        error: {
          message: "Failed to fetch vulnerabilities",
          code: (error as any)?.code,
        },
      };
    }
  },

  /**
   * Get a single vulnerability by ID
   */
  async getById(vulnId: string): Promise<ApiResponse<ScanFinding>> {
    try {
      const { data, error } = await supabase
        .from("scan_findings")
        .select("*")
        .eq("id", vulnId)
        .single();

      if (error) throw error;

      return { data };
    } catch (error) {
      console.error("Error fetching vulnerability:", error);
      return {
        error: {
          message: "Failed to fetch vulnerability",
          code: (error as any)?.code,
        },
      };
    }
  },

  /**
   * Create a new vulnerability finding
   */
  async create(dto: CreateVulnerabilityDto): Promise<ApiResponse<ScanFinding>> {
    try {
      const { data, error } = await supabase
        .from("scan_findings")
        .insert({
          scan_id: dto.scan_id,
          title: dto.title,
          description: dto.description,
          severity: dto.severity,
          cve_id: dto.cve_id || null,
          affected_component: dto.affected_component || null,
          remediation_steps: dto.remediation_steps || null,
          reference_urls: dto.reference_urls || null,
        })
        .select()
        .single();

      if (error) throw error;

      return { data };
    } catch (error) {
      console.error("Error creating vulnerability:", error);
      return {
        error: {
          message: "Failed to create vulnerability",
          code: (error as any)?.code,
        },
      };
    }
  },

  /**
   * Get count of vulnerabilities by severity for a scan
   */
  async getCountBySeverity(
    scanId: string
  ): Promise<ApiResponse<Record<SeverityLevel, number>>> {
    try {
      const { data, error } = await supabase
        .from("scan_findings")
        .select("severity")
        .eq("scan_id", scanId);

      if (error) throw error;

      const counts: Record<SeverityLevel, number> = {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0,
      };

      (data || []).forEach((finding) => {
        if (finding.severity) {
          counts[finding.severity as SeverityLevel]++;
        }
      });

      return { data: counts };
    } catch (error) {
      console.error("Error counting vulnerabilities:", error);
      return {
        error: {
          message: "Failed to count vulnerabilities",
          code: (error as any)?.code,
        },
      };
    }
  },

  /**
   * Get top vulnerabilities for a user (across all scans)
   */
  async getTopVulnerabilities(
    userId: string,
    limit = 10
  ): Promise<ApiResponse<ScanFinding[]>> {
    try {
      const { data, error } = await supabase
        .from("scan_findings")
        .select(
          `
          *,
          vulnerability_scans!inner(user_id)
        `
        )
        .eq("vulnerability_scans.user_id", userId)
        .order("created_at", { ascending: false })
        .limit(limit);

      if (error) throw error;

      return { data: data || [] };
    } catch (error) {
      console.error("Error fetching top vulnerabilities:", error);
      return {
        error: {
          message: "Failed to fetch top vulnerabilities",
          code: (error as any)?.code,
        },
      };
    }
  },

  /**
   * Get vulnerabilities by severity level
   */
  async getBySeverity(
    scanId: string,
    severity: SeverityLevel
  ): Promise<ApiResponse<ScanFinding[]>> {
    try {
      const { data, error } = await supabase
        .from("scan_findings")
        .select("*")
        .eq("scan_id", scanId)
        .eq("severity", severity)
        .order("created_at", { ascending: false });

      if (error) throw error;

      return { data: data || [] };
    } catch (error) {
      console.error("Error fetching vulnerabilities by severity:", error);
      return {
        error: {
          message: "Failed to fetch vulnerabilities",
          code: (error as any)?.code,
        },
      };
    }
  },
};
